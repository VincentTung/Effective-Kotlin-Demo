26.每个函数应该按照 单层抽象（single level of abstraction）的规则编写

计算机是一种极其复杂的设备，但我们可以使用这要归功于它的复杂性被分不同层中的元素。
从程序员的角度来说，计算机最底层的抽象层是硬件。往上，我们一般为处理编写代码，下一个有趣的层级是处理器控制指令。为了便于阅读，它们以一种非常简单的语言表达，并一对一地翻译成这些命令。这种语言叫做汇编语言。使用汇编语言进行开发是困难的，这样构建今天的应用程序是绝对不可想象的。为了简化编程，工程师们引入编译器：一个能将一门语言翻译成另一门的程序。早期的编译器是用汇编语言写的，它们将代码转换成汇编指令。这就是第一门高级语言是如何诞生的。转而，它们被用来给高级语言编写编译器。于是，引入了C,C++和其他高级语言。这些语言用来编写程序和应用。 后来，抽象机制和解释语言的概念被发明出来，很难将 Java 或 JavaScript 这样的语言放在这个金字塔上，但抽象层的一般概念仍然是一个想法。
 具有良好分离层的一大优势是，当一个人在特定层上操作时，它们可以依赖较低的层按预期工作，而无需完全了解细节。我们可以在不了解汇编程序或JVM字节码的情况下进行编程，这很方便。同样，当汇编程序或者JVM字节码需要更改的时候，只要创建器适配了上层，不要担忧影响程序。开发者在单独的层上操作，通常是为上层构建。开发者应该知道这些，这是很实用的。

![image.png](https://cdn.nlark.com/yuque/0/2022/png/10378482/1655976093114-69838959-eb44-4c3b-9859-f16d2ea95b5f.png#clientId=u162dcf96-7b6c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=385&id=u7db30cf5&margin=%5Bobject%20Object%5D&name=image.png&originHeight=385&originWidth=643&originalType=binary&ratio=1&rotation=0&showTitle=false&size=21065&status=done&style=none&taskId=uc54651a2-6ee2-442f-a694-d5a7bba862a&title=&width=643)

**抽象级别**

如你所见，层是建立在计算机科学中的层之上的**。** 这就是为什么计算机科学家开始区分事物的层级有多高的原因。层级越高，就离着物理学越远。在编程中，我们说层级越高，离处理器越远。层级越高，我们需要担心的细节越少。同样这样简单性的代价就是缺乏控制。在C中，内存管理是很重要的工作。在Java中，垃圾回收器能够为你自动处理内存，但是提高内存的使用很困难。

**单层抽象原则**

就像计算机科学问题被提起到分散的层级中一样，同样我们可以在代码中创建抽象层。使用最基础的工具就是函数。同样，和计算机一样，我们喜欢每次在单独的抽象层上进行操作。这就是为什么编程社区开发了“单层抽象”的原则，内容如下：**每个函数应该按照单层抽象规则编写**。
假设你需要创建一个类，这个类代表了咖啡机，包含了一个按钮，用来制作咖啡。制作咖啡包含一些复杂的操作，需要使用咖啡机的不同部分。我们使用一个包含名为mackCoffee函数的类来代表它。我们要在这个唯一的函数里面明确的实现所有必须的逻辑：
```kotlin
 class CoffeeMachine { 
     fun makeCoffee() {
         // Declarations of hundreds of variables
         // Complex logic to coordinate everything
         // with many low-level optimizations
     }
 }
```
这个函数可能会有几百行。相信我，我见过类似的景象。特别是在老的程序中。这样的函数是相当难读懂的。这种函数确实难懂的原因是，当我们阅读代码的时候，我们不断的将注意力放在细节上。同事在函数里进行查找也是困难的。设想你被要求去做一个很小的修改，比如修改谁的问题，为了实现这个，你可能需要弄懂整个函数，这很困难。我们的记忆里是有限的，我们不想一个开发者将时间浪费在不必要的细节上。这就是为什么将高级步骤作为单独的函数提取得更好：

```kotlin
class CoffeeMachine {
    
    fun makeCoffee() {
        boilWater()
        brewCoffee()
        pourCoffee()
        pourMilk()
    }
    
    private fun boilWater() {
        // ...
    }

    private fun brewCoffee() {

        // ...
    }

    private fun pourCoffee() {
        // ...
    }
    
    private fun pourMilk() {
        // ...
    }
    
}
```

现在你能够清晰的看到函数的工作流程。这些私有函数就像书中的章节。因此，如果你需要修改某些东西，你可以直接跳到它实现的地方。我们只是提取了高级的步骤，这大大简化了我们对于程序的立即。我们将它变得可读了，如果有人想要去理解低层的逻辑，他们可以直接跳到那，并开始阅读。通过提取非常简答的抽象，我们提高了可读性。
根据这条规则，所有的新函数应该一样简单。一般来说，函数应该是尽量小和拥有尽量少的职责。如果它们中的一个是负责的，我们应该立马提取抽象层。结果是，我们实现很多小和可读的函数，所有这些都集中在单层抽象上。在每个抽象级别，我们都使用抽象术语（方法和类）进行操作，如果你想弄懂它们，可以跳到它们定义的地方。这样做，在提取这些函数的时候没有损失任何东西，并且是我们的代码变得易读了。
额外的好处是提取的函数更加容易重用和测试。假设我们现在需要写一个单独的函数来生产浓缩咖啡，区别在于它没有牛奶。当处理部分被提取的时候，我们现在可以轻松的重用它们：
```kotlin
fun makeEspressoCoffee() {
    boilWater()
    brewCoffee()
    pourCoffee()
}
```
这样也是为了让我们现在可以单独测试更小的函数，如开水或啤酒咖啡，而不是更复杂的功能，如制作咖啡或制作浓缩咖啡

**程序架构中的抽象级别**

抽象层的概念也适用于比函数更高的层次。我们分离抽象来隐藏子系统的细节，允许关分离关注点以促进互操作性和平台独立性。这意味着在问题域术语中定义更高的级别。


![image.png](https://cdn.nlark.com/yuque/0/2022/png/10378482/1655981352036-fd88ca00-e3a7-49e7-8e5b-4e13add50e1c.png#clientId=u162dcf96-7b6c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=401&id=u87345165&margin=%5Bobject%20Object%5D&name=image.png&originHeight=401&originWidth=565&originalType=binary&ratio=1&rotation=0&showTitle=false&size=29668&status=done&style=none&taskId=uc33d856b-b430-4ec9-b0cd-8c29e44020e&title=&width=565)

当我们设计模块化系统的时候这中概念也是很重要的。分离的模块是强分离的，可以隐藏特定层的元素。当我们谢应用的时候，一般的理解是 这些模块代表输入或输出（前端展示，后端处理http请求）是低层级的模块。从另一方面说，这些代表着用例和业务逻辑的模块是高层级。
我们说具有良好分层的项目进行了分层。在一个良好分层过的工程中，一个人可以在任意单个层级观察这个系统，且能够获得一致的视图。通常程序中一般是希望分层的。

**总结**

在编程中使用分离的抽象层级是一个流行的概念。它帮助我们组织知识，隐藏子系统的细节，允许分离的概念来分离交互性和平台依赖。我们用各种方式分离抽象，像函数，类，模块。在一个单独的层级上进行较小的抽象操作是很容易理解的。抽象层级的一般观念是越靠近具体的操作，比如处理器或者输入、输出，层级越低。在一个较低层级的抽象层我们为高层级定义了语言的条件。
